#!/bin/env python3
{{ansible_managed | comment(decoration="#")}}

"""
Inspired by https://github.com/jeroenh/signzone/blob/master/signzone.sh
and https://www.digitalocean.com/community/tutorials/how-to-set-up-dnssec-on-an-nsd-nameserver-on-ubuntu-14-04
Thanks Jeroen van der Ham and Digital Ocean :)
"""

import argparse
from datetime import datetime, timedelta
import logging
import os
from pathlib import Path
import re
import subprocess
import sys
import time

logging.basicConfig(level="INFO")
logger = logging.getLogger()

# Globals
NSD_DIR = "{{ nsd_directory }}"
ZONE_DIR = "{{ nsd_server_zones_dir }}"

KSK_DIR = "{{ nsd_server_dnssec_key_dir }}/KSK"
KSK_ALGO = "{{ nsd_zones_attributes[zone_name].dnssec.algo }}"
ZSK_DIR = "{{ nsd_server_dnssec_key_dir }}/ZSK"
ZSK_ALGO = "{{ nsd_zones_attributes[zone_name].dnssec.algo }}"

TTL_MARKER = "Refresh"
EXP_MARKER = r"IN(\s)+RRSIG(\s)SOA"

ZSK_ROLL_OVER = timedelta(days=7)
ZSK_ROLL_OVER_WEEKDAY = 3  # Thursday
ZSK_GRACE_PERIOD = timedelta(days=1)
PROPAGATION_DELAY = timedelta(minutes=1)

DNS_TS_FORMAT = "%Y%m%d%H%M%S"


def get_key_filenames(directory: str, domain: str):
    """get the basename of the keyfiles from the specified directory,
    return the list"""

    key_files = []

    for _, _, filenames in os.walk(directory):

        for filename in filenames:
            if domain in filename:

                # only append filename not whole filename
                key_files.append(Path(filename).stem)

    # sort the keyfile, with newest IDs first
    key_files.sort(reverse=True)

    key_files = list(set(key_files))

    return key_files


def get_keys(
    directory: str,
    domain: str,
    ksk=False,
    amount_of_keys: int = 2,
    keep_current_keys: bool = False,
) -> list[str]:
    """

    Args:
        directory (str):
        domain (str):

    Returns: list of zone keys

    """

    if ksk:
        algo = KSK_ALGO

        logger.info("getting key signing keys...")
    else:
        algo = ZSK_ALGO
        logger.info("getting zone signing keys...")

    current_keys = get_key_filenames(directory, domain)

    if ksk:
        extensions = {"ds", "key", "private"}
    else:
        extensions = {"key", "private"}

    if keep_current_keys:
        while len(current_keys) > amount_of_keys:

            old_key = current_keys.pop()

            try:
                for ext in extensions:
                    subprocess.run(["rm", f"{directory}/{old_key}.{ext}"], check=True)

            except subprocess.CalledProcessError as e:
                logger.exception("Error removing old key: %s", e)
                raise

            current_keys = get_key_filenames(directory, domain)
    else:
        while len(current_keys) >= amount_of_keys:
            old_key = current_keys.pop()

            try:
                for ext in extensions:
                    subprocess.run(["rm", f"{directory}/{old_key}.{ext}"], check=True)
            except subprocess.CalledProcessError as e:
                logger.exception("Error removing old key: %s", e)
                raise

            current_keys = get_key_filenames(directory, domain)

    while not len(current_keys) == amount_of_keys:

        os.chdir(directory)

        try:
            if ksk:
                subprocess.run(["ldns-keygen", "-a", algo, "-k", domain], check=True)
            else:
                subprocess.run(["ldns-keygen", "-a", algo, domain], check=True)
        except subprocess.CalledProcessError as e:
            logger.exception("Error creating key: %s", e)

        os.chdir(NSD_DIR)
        time.sleep(3)

        current_keys = get_key_filenames(directory, domain)

    return current_keys


def increment_serial(file):
    """replace pattern in file, taken from
    https://stackoverflow.com/questions/39086/search-and-replace-a-line-in-a-file-in-python"""

    # Read contents from file as a single string
    file_handle = open(file, "r")
    file_string = file_handle.read()
    file_handle.close()

    # Use RE package to allow for replacement (also allowing for (multiline) REGEX)
    file_string = re.sub(
        r"^(\s+)(\d+)(\s*;\s*Serial\s*)$",
        lambda exp: f"        {int(exp.groups()[1]) + 1} ; Serial",
        file_string,
        flags=re.IGNORECASE | re.MULTILINE,
    )

    # Write contents to file.
    # Using mode 'w' truncates the file.
    file_handle = open(file, "w")
    file_handle.write(file_string)
    file_handle.close()


def get_zone_signing_keys(
    directory: str, domain: str, num_of_keys: int = 2, keep_current_keys: bool = False
) -> list[str]:
    """get the zone signing keys"""
    return get_keys(
        directory,
        domain,
        ksk=False,
        amount_of_keys=num_of_keys,
        keep_current_keys=keep_current_keys,
    )


def get_key_signing_keys(
    directory: str, domain: str, num_of_keys: int = 1, keep_current_keys: bool = False
) -> list[str]:
    """get the key signing keys"""
    return get_keys(
        directory,
        domain,
        ksk=True,
        amount_of_keys=num_of_keys,
        keep_current_keys=keep_current_keys,
    )


def grep_zone(domain: str):
    """find TTL based on marker 'refresh'"""

    try:
        grepper = subprocess.run(
            f'cat {ZONE_DIR}/{domain}.zone | grep -i "{TTL_MARKER}"',
            capture_output=True,
            shell=True,
            check=True,
        )

        # split num; TTL -> num
        ttl = grepper.stdout.decode("utf-8").split(";")[0].strip()

        grepper = subprocess.run(
            f'cat {ZONE_DIR}/{domain}.zone.signed | egrep -i "{EXP_MARKER}"',
            capture_output=True,
            shell=True,
            check=True,
        )

        # find time (IN DNSKEY record)
        expire_dns_ts = grepper.stdout.decode("utf-8")

        # Record - TTL - IN - RRSIG
        # Type - Algorithm - TLL - Signature, so place 8
        expire_dns_ts = expire_dns_ts.split()[8].strip()
        expire = datetime.strptime(expire_dns_ts, DNS_TS_FORMAT)

        return ttl, expire

    except subprocess.CalledProcessError as e:
        logger.exception("Error grepping zonefile: %s", e)

        return None, None


def sign_zone(domain: str, zsks: list[str], ksks: list[str], expiration):
    """sign domain with given KSK and ZSK"""

    today = datetime.now()

    try:
        # increment serial of unsigned zonefile
        increment_serial(f"{ZONE_DIR}/{domain}.zone")

        logger.info("signing zone: %s", domain)

        # actually sign zone
        subprocess.run(
            f"ldns-signzone -b "
            + f"-i {today.timestamp()} -e {expiration.timestamp()} -n "
            + f"-s $(head -n 1001 /dev/random | sha1sum | cut -b 1-16) -f {ZONE_DIR}/{domain}.zone.signed "
            + f"{ZONE_DIR}/{domain}.zone "
            + " ".join([f"{ZSK_DIR}/{zsk}" for zsk in zsks])
            + " "
            + " ".join([f"{KSK_DIR}/{ksk}" for ksk in ksks]),
            check=True,
            shell=True,
        )

    except subprocess.CalledProcessError as e:
        logger.exception("Error running signzone: %s", e)
        raise

    logger.info("signed domain: %s", domain)


def reload_zone(domain: str):
    """reload the given nsd zone"""

    try:
        subprocess.run(["/usr/sbin/nsd-control", "reload", str(domain)], check=True)
    except subprocess.CalledProcessError as e:
        logger.exception("Error reloading zone: %s", e)

    logger.info("reloaded zone: %s", domain)


def ksk_rollover():
    raise NotImplemented("Not there yet!")


def create_signed_zone(num_zsk: int, num_ksk: int, domain: str) -> None:

    zsks = get_zone_signing_keys(
        ZSK_DIR, domain, num_of_keys=num_zsk, keep_current_keys=True
    )
    ksks = get_key_signing_keys(
        KSK_DIR, domain, num_of_keys=num_ksk, keep_current_keys=True
    )

    now = datetime.now()

    if not (now.weekday == ZSK_ROLL_OVER_WEEKDAY and now.hour < 12):

        # fetch next Thursday
        while not now.weekday() == ZSK_ROLL_OVER_WEEKDAY:
            now += timedelta(days=1)

    # when it is already thursday before 12, the rotation is today.
    # expire is today at noon + grace period
    expire = now.replace(hour=12, minute=0, second=0, microsecond=0) + ZSK_GRACE_PERIOD

    sign_zone(domain, [zsks[0]], ksks, expire)
    reload_zone(domain)


def update_signed_zone(num_zsk: int, num_ksk: int, domain: str) -> None:

    zsks = get_zone_signing_keys(
        ZSK_DIR, domain, num_of_keys=num_zsk, keep_current_keys=True
    )
    ksks = get_key_signing_keys(
        KSK_DIR, domain, num_of_keys=num_ksk, keep_current_keys=True
    )

    ttl, expire = grep_zone(domain)

    if not ttl or not expire:
        print("TTL not found")
        sys.exit(1)

    sign_zone(domain, [zsks[0]], ksks, expire)
    reload_zone(domain)


def zsk_rollover(num_zsk: int, num_ksk, domain: str, keep_old_keys=False) -> None:
    """do a zone key roll over"""

    zsks = get_zone_signing_keys(ZSK_DIR, domain, num_of_keys=num_zsk)
    ksks = get_key_signing_keys(
        KSK_DIR, domain, num_of_keys=num_ksk, keep_current_keys=True
    )

    ttl, expire = grep_zone(domain)

    if not ttl or not expire:
        print("TTL not found")
        sys.exit(1)

    now = datetime.now()

    # set rollover at 12 noon
    new_expiration = (
        now.replace(hour=12, minute=0, second=0, microsecond=0)
        + ZSK_ROLL_OVER
        + ZSK_GRACE_PERIOD
    )

    if not now.date() == expire.date() - ZSK_GRACE_PERIOD:
        logger.info(
            "Forced rollover, next date should have been %s, %s instead",
            now.date(),
            expire.date(),
        )
    else:
        logger.info("Planned rollover.")

    logger.info(
        "Intermediary signing of zone %s with keys: ZSK: (%s) KSK: (%s) with validity: %s",
        domain,
        " ".join(zsks),
        " ".join(ksks),
        now + timedelta(days=1),
    )
    # sign domain with both keys
    sign_zone(domain, zsks, ksks, new_expiration)
    reload_zone(domain)

    # calculate waiting time, based on zone max TTL and propagation delay
    waiting_time = int(
        (timedelta(seconds=int(ttl)) + PROPAGATION_DELAY).total_seconds()
    )

    logger.info("Sleeping TTL of zone + propagation delay : %s ", waiting_time)
    time.sleep(waiting_time)

    # discard oldest key
    oldest_key = zsks.pop()

    # sign the zone only with the newest key(s)
    logger.info(
        "Signing zone %s with keys: ZSK: (%s) KSK: (%s) until: %s",
        domain,
        " ".join(zsks),
        " ".join(ksks),
        now + timedelta(days=1),
    )

    sign_zone(domain, [zsks[0]], ksks, new_expiration)

    logger.info(
        "Signing zone %s succeeded",
        domain,
    )

    logger.info("Reloading zone %s", domain)
    reload_zone(domain)

    logger.info(
        "Reloaded zone %s",
        domain,
    )

    if not keep_old_keys:

        logger.info("Removing oldest key: %s", ZSK_DIR + "/" + oldest_key)

        extensions = {"key", "private"}

        try:
            for ext in extensions:
                subprocess.run(["rm", f"{ZSK_DIR}/{oldest_key}.{ext}"], check=True)

        except subprocess.CalledProcessError as e:
            logger.exception("Error reloading zone: %s", e)

        logger.info("Removed oldest key: %s", ZSK_DIR + "/" + oldest_key)


def main():
    """main function to implement stuff related to DNSSEC, currenty can do:
    - a keyrollover of ZSKs
    - a update of a zone
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "action",
        choices=["zsk_rollover", "ksk_rollover", "update_zone", "create_zone"],
        help="keytype to rollover ",
    )
    parser.add_argument("domain", type=str, help="domain to do action on")
    parser.add_argument(
        "--num_zsk", type=int, default=2, help="number of zone signing keys"
    )
    parser.add_argument(
        "--num_ksk", type=int, default=1, help="number of keys signing keys"
    )
    parser.add_argument(
        "--keep_old_keys", type=bool, default=False, help="whether to keep old keys"
    )

    args = parser.parse_args()

    # change to NSD dir
    os.chdir(NSD_DIR)

    match args.action:
        case "zsk_rollover":
            zsk_rollover(
                args.num_zsk,
                args.num_ksk,
                args.domain,
                keep_old_keys=args.keep_old_keys,
            )
        case "ksk_rollover":
            raise NotImplemented("Not yet there!")
        case "update_zone":
            update_signed_zone(args.num_zsk, args.num_ksk, args.domain)
        case "create_zone":
            create_signed_zone(args.num_zsk, args.num_ksk, args.domain)
        case _:
            raise ValueError("Invalid action!")


if __name__ == "__main__":
    main()
